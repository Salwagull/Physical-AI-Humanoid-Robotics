"use strict";(globalThis.webpackChunkphysical_ai_robotics_book=globalThis.webpackChunkphysical_ai_robotics_book||[]).push([[439],{5058:(n,e,r)=>{r.r(e),r.d(e,{assets:()=>a,contentTitle:()=>t,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"chapter4_gazebo_simulation","title":"Chapter 4: Gazebo for Robot Simulation","description":"Introduction","source":"@site/docs/chapter4_gazebo_simulation.md","sourceDirName":".","slug":"/chapter4_gazebo_simulation","permalink":"/Physical-AI-Humanoid-Robotics/docs/chapter4_gazebo_simulation","draft":false,"unlisted":false,"editUrl":"https://github.com/Salwagull/Physical-AI-Humanoid-Robotics/tree/main/docs/chapter4_gazebo_simulation.md","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"sidebar_position":5},"sidebar":"tutorialSidebar","previous":{"title":"Chapter 3: ROS 2 Basics - Nodes, Topics, Services","permalink":"/Physical-AI-Humanoid-Robotics/docs/chapter3_ros2_basics"},"next":{"title":"Chapter 5: Unity for Robotics Simulation","permalink":"/Physical-AI-Humanoid-Robotics/docs/chapter5_unity_simulation"}}');var s=r(4848),l=r(8453);const o={sidebar_position:5},t="Chapter 4: Gazebo for Robot Simulation",a={},d=[{value:"Introduction",id:"introduction",level:2},{value:"Conceptual Overview",id:"conceptual-overview",level:2},{value:"What is Gazebo?",id:"what-is-gazebo",level:3},{value:"Gazebo Architecture",id:"gazebo-architecture",level:3},{value:"Robot Modeling: SDF vs URDF",id:"robot-modeling-sdf-vs-urdf",level:3},{value:"Physics Simulation",id:"physics-simulation",level:3},{value:"Sensor Simulation",id:"sensor-simulation",level:3},{value:"Technical Implementation",id:"technical-implementation",level:2},{value:"Installing Gazebo with ROS 2",id:"installing-gazebo-with-ros-2",level:3},{value:"Creating Your First World",id:"creating-your-first-world",level:3},{value:"Creating a Simple Mobile Robot",id:"creating-a-simple-mobile-robot",level:3},{value:"Controlling the Robot with ROS 2",id:"controlling-the-robot-with-ros-2",level:3},{value:"Adding a Lidar Sensor",id:"adding-a-lidar-sensor",level:3},{value:"Practical Example: Autonomous Navigation in Gazebo",id:"practical-example-autonomous-navigation-in-gazebo",level:2},{value:"Visual Aids",id:"visual-aids",level:2},{value:"Gazebo Simulation Pipeline",id:"gazebo-simulation-pipeline",level:3},{value:"SDF Model Structure",id:"sdf-model-structure",level:3},{value:"Summary and Next Steps",id:"summary-and-next-steps",level:2},{value:"Exercises and Challenges",id:"exercises-and-challenges",level:2},{value:"Further Reading",id:"further-reading",level:2}];function c(n){const e={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,l.R)(),...n.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(e.header,{children:(0,s.jsx)(e.h1,{id:"chapter-4-gazebo-for-robot-simulation",children:"Chapter 4: Gazebo for Robot Simulation"})}),"\n",(0,s.jsx)(e.h2,{id:"introduction",children:"Introduction"}),"\n",(0,s.jsx)(e.p,{children:"Gazebo is the industry-standard robot simulator, used by robotics researchers and developers worldwide. It provides a powerful physics engine, realistic sensor simulation, and seamless integration with ROS 2. Before deploying to real hardware\u2014which is expensive, time-consuming, and sometimes dangerous\u2014you can test your algorithms in Gazebo's virtual environments."}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Learning Objectives:"})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Understand Gazebo's architecture and physics engine"}),"\n",(0,s.jsx)(e.li,{children:"Learn about robot modeling with SDF and URDF formats"}),"\n",(0,s.jsx)(e.li,{children:"Create and spawn robots in simulated worlds"}),"\n",(0,s.jsx)(e.li,{children:"Integrate Gazebo with ROS 2 for robot control"}),"\n",(0,s.jsx)(e.li,{children:"Simulate sensors (cameras, lidar) and actuators"}),"\n",(0,s.jsx)(e.li,{children:"Build reproducible testing environments"}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Prerequisites:"})," Chapter 3 (ROS 2 Basics), familiarity with XML, basic physics concepts"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Why This Matters:"})," Simulation is essential for modern robotics development. Gazebo lets you iterate rapidly, test edge cases safely, and generate synthetic training data\u2014all before touching real hardware. It's the bridge between theory and practice."]}),"\n",(0,s.jsx)(e.h2,{id:"conceptual-overview",children:"Conceptual Overview"}),"\n",(0,s.jsx)(e.h3,{id:"what-is-gazebo",children:"What is Gazebo?"}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Gazebo"})," is an open-source 3D robot simulator that provides:"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Physics Simulation"}),": Realistic dynamics, collisions, friction, and gravity"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Sensor Simulation"}),": Cameras, lidar, IMU, GPS, force/torque sensors"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Actuator Simulation"}),": Motors, grippers, wheels with realistic response"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Rendering"}),": High-quality 3D visualization of robots and environments"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"ROS 2 Integration"}),": Bidirectional communication with ROS 2 nodes"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Plugin System"}),": Extend functionality with custom C++ or Python plugins"]}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Common Use Cases:"})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Algorithm development and testing"}),"\n",(0,s.jsx)(e.li,{children:"Reinforcement learning for robot control"}),"\n",(0,s.jsx)(e.li,{children:"Multi-robot coordination experiments"}),"\n",(0,s.jsx)(e.li,{children:"Sensor fusion validation"}),"\n",(0,s.jsx)(e.li,{children:"Hardware-in-the-loop testing"}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"gazebo-architecture",children:"Gazebo Architecture"}),"\n",(0,s.jsx)(e.p,{children:"Gazebo is built on several core components:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502                   Gazebo Simulator                       \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502                                                          \u2502\r\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510           \u2502\r\n\u2502  \u2502  Physics       \u2502      \u2502   Rendering     \u2502           \u2502\r\n\u2502  \u2502  Engine        \u2502      \u2502   Engine        \u2502           \u2502\r\n\u2502  \u2502  (ODE/Bullet/  \u2502      \u2502   (OGRE)        \u2502           \u2502\r\n\u2502  \u2502   Simbody)     \u2502      \u2502                 \u2502           \u2502\r\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518           \u2502\r\n\u2502           \u2502                       \u2502                     \u2502\r\n\u2502           \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                     \u2502\r\n\u2502                       \u2502                                 \u2502\r\n\u2502               \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                        \u2502\r\n\u2502               \u2502   World Model  \u2502                        \u2502\r\n\u2502               \u2502   (SDF/URDF)   \u2502                        \u2502\r\n\u2502               \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                        \u2502\r\n\u2502                       \u2502                                 \u2502\r\n\u2502        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                 \u2502\r\n\u2502        \u2502              \u2502              \u2502                 \u2502\r\n\u2502    \u250c\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2510            \u2502\r\n\u2502    \u2502Sensors\u2502    \u2502 Robots  \u2502    \u2502 Objects \u2502            \u2502\r\n\u2502    \u2514\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2518            \u2502\r\n\u2502        \u2502             \u2502              \u2502                  \u2502\r\n\u2502        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                  \u2502\r\n\u2502                      \u2502                                 \u2502\r\n\u2502              \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                        \u2502\r\n\u2502              \u2502   ROS 2 Bridge \u2502                        \u2502\r\n\u2502              \u2502   (ros_gz)     \u2502                        \u2502\r\n\u2502              \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                        \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n                       \u2502\r\n                \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n                \u2502  ROS 2 Nodes\u2502\r\n                \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Key Components:"})}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Physics Engine"}),": Simulates real-world physics (gravity, collisions, forces)"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Rendering Engine"}),": Creates 3D visualizations"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"World Model"}),": Defines environments, robots, and their properties"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Sensors & Actuators"}),": Simulated hardware components"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"ROS 2 Bridge"}),": Connects Gazebo to ROS 2 ecosystem"]}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"robot-modeling-sdf-vs-urdf",children:"Robot Modeling: SDF vs URDF"}),"\n",(0,s.jsx)(e.p,{children:"Robots in Gazebo are described using model files:"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"SDF (Simulation Description Format)"})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Gazebo's native format"}),"\n",(0,s.jsx)(e.li,{children:"Supports advanced features (nested models, multiple robots)"}),"\n",(0,s.jsx)(e.li,{children:"More expressive than URDF"}),"\n",(0,s.jsx)(e.li,{children:"XML-based"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"URDF (Unified Robot Description Format)"})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Originally from ROS 1"}),"\n",(0,s.jsx)(e.li,{children:"Widely used in robotics community"}),"\n",(0,s.jsx)(e.li,{children:"Focuses on kinematics (links and joints)"}),"\n",(0,s.jsx)(e.li,{children:"Can be converted to SDF"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"When to use what:"})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"SDF"}),": Complex simulations, multiple robots, advanced sensors"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"URDF"}),": ROS 2 integration, MoveIt motion planning, existing robot descriptions"]}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"For this chapter, we'll primarily use SDF for its simplicity and Gazebo-native features."}),"\n",(0,s.jsx)(e.h3,{id:"physics-simulation",children:"Physics Simulation"}),"\n",(0,s.jsx)(e.p,{children:"Gazebo uses physics engines to simulate real-world dynamics:"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Supported Physics Engines:"})}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"ODE (Open Dynamics Engine)"})," - Default, fast, good for most use cases"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Bullet"})," - Better collision detection, soft body physics"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Simbody"})," - High accuracy, slower, used for biomechanics"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"DART"})," - Differentiable physics, good for machine learning"]}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"What Physics Simulates:"})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Gravity"}),": Objects fall, robots need to maintain balance"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Collisions"}),": Robots can't pass through walls"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Friction"}),": Wheels slip on smooth surfaces"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Inertia"}),": Heavy objects are harder to accelerate"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Joint Dynamics"}),": Motors have torque limits, gears have backlash"]}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Physics Configuration:"}),"\r\nYou can adjust simulation parameters:"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Time step (smaller = more accurate, slower)"}),"\n",(0,s.jsx)(e.li,{children:"Solver iterations (more = stable, slower)"}),"\n",(0,s.jsx)(e.li,{children:"Gravity direction and magnitude"}),"\n",(0,s.jsx)(e.li,{children:"Contact properties (friction coefficients, restitution)"}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"sensor-simulation",children:"Sensor Simulation"}),"\n",(0,s.jsx)(e.p,{children:"Gazebo simulates a wide range of sensors:"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Vision Sensors:"})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"RGB Camera"}),": Color images"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Depth Camera"}),": Distance to objects"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Stereo Camera"}),": Two cameras for stereo vision"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"360\xb0 Camera"}),": Panoramic views"]}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Range Sensors:"})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Lidar"}),": Laser range finder (2D or 3D)"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Sonar"}),": Ultrasonic distance sensor"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Radar"}),": Long-range detection"]}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Motion Sensors:"})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"IMU"}),": Accelerometer + gyroscope + magnetometer"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"GPS"}),": Global positioning"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Odometry"}),": Wheel encoder-based position estimation"]}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Contact Sensors:"})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Bumper"}),": Detects collisions"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Force/Torque"}),": Measures forces on joints"]}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"Each sensor publishes data to ROS 2 topics, exactly like real hardware would."}),"\n",(0,s.jsx)(e.h2,{id:"technical-implementation",children:"Technical Implementation"}),"\n",(0,s.jsx)(e.h3,{id:"installing-gazebo-with-ros-2",children:"Installing Gazebo with ROS 2"}),"\n",(0,s.jsx)(e.p,{children:"Gazebo Harmonic (latest) works with ROS 2 Humble:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:"# Install Gazebo Harmonic\r\nsudo apt-get update\r\nsudo apt-get install gz-harmonic\r\n\r\n# Install ROS 2 - Gazebo bridge\r\nsudo apt-get install ros-humble-ros-gz\n"})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Verify installation:"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:"gz sim --version\r\n# Should output: Gazebo Sim, version 8.x.x\n"})}),"\n",(0,s.jsx)(e.h3,{id:"creating-your-first-world",children:"Creating Your First World"}),"\n",(0,s.jsx)(e.p,{children:"A Gazebo world defines the environment. Let's create a simple world with a ground plane and some obstacles."}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsxs)(e.strong,{children:["File: ",(0,s.jsx)(e.code,{children:"simple_world.sdf"})]})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-xml",children:'<?xml version="1.0" ?>\r\n<sdf version="1.8">\r\n  <world name="simple_world">\r\n\r\n    \x3c!-- Physics settings --\x3e\r\n    <physics name="1ms" type="ode">\r\n      <max_step_size>0.001</max_step_size>\r\n      <real_time_factor>1</real_time_factor>\r\n    </physics>\r\n\r\n    \x3c!-- Lighting --\x3e\r\n    <light type="directional" name="sun">\r\n      <pose>0 0 10 0 0 0</pose>\r\n      <diffuse>1 1 1 1</diffuse>\r\n      <specular>0.5 0.5 0.5 1</specular>\r\n      <direction>-0.5 0.1 -0.9</direction>\r\n    </light>\r\n\r\n    \x3c!-- Ground plane --\x3e\r\n    <model name="ground_plane">\r\n      <static>true</static>\r\n      <link name="link">\r\n        <collision name="collision">\r\n          <geometry>\r\n            <plane>\r\n              <normal>0 0 1</normal>\r\n            </plane>\r\n          </geometry>\r\n        </collision>\r\n        <visual name="visual">\r\n          <geometry>\r\n            <plane>\r\n              <normal>0 0 1</normal>\r\n              <size>100 100</size>\r\n            </plane>\r\n          </geometry>\r\n          <material>\r\n            <ambient>0.8 0.8 0.8 1</ambient>\r\n            <diffuse>0.8 0.8 0.8 1</diffuse>\r\n          </material>\r\n        </visual>\r\n      </link>\r\n    </model>\r\n\r\n    \x3c!-- Obstacle: Box --\x3e\r\n    <model name="box_obstacle">\r\n      <pose>2 0 0.5 0 0 0</pose>\r\n      <link name="link">\r\n        <collision name="collision">\r\n          <geometry>\r\n            <box>\r\n              <size>1 1 1</size>\r\n            </box>\r\n          </geometry>\r\n        </collision>\r\n        <visual name="visual">\r\n          <geometry>\r\n            <box>\r\n              <size>1 1 1</size>\r\n            </box>\r\n          </geometry>\r\n          <material>\r\n            <ambient>1 0 0 1</ambient>\r\n            <diffuse>1 0 0 1</diffuse>\r\n          </material>\r\n        </visual>\r\n      </link>\r\n    </model>\r\n\r\n  </world>\r\n</sdf>\n'})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Running the world:"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:"gz sim simple_world.sdf\n"})}),"\n",(0,s.jsx)(e.p,{children:"This opens the Gazebo GUI with a ground plane and a red box obstacle."}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Key SDF Elements:"})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"<world>"}),": Container for the entire simulation"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"<physics>"}),": Defines physics engine and time step"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"<light>"}),": Illumination sources"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"<model>"}),": Entities in the world (static or dynamic)"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"<link>"}),": Physical bodies with collision and visual geometry"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"<pose>"}),": Position (x, y, z) and orientation (roll, pitch, yaw)"]}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"creating-a-simple-mobile-robot",children:"Creating a Simple Mobile Robot"}),"\n",(0,s.jsx)(e.p,{children:"Now let's create a differential drive robot\u2014two wheels and a caster."}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsxs)(e.strong,{children:["File: ",(0,s.jsx)(e.code,{children:"diff_drive_robot.sdf"})]})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-xml",children:'<?xml version="1.0" ?>\r\n<sdf version="1.8">\r\n  <model name="diff_drive_robot">\r\n\r\n    \x3c!-- Robot base --\x3e\r\n    <link name="base_link">\r\n      <pose>0 0 0.1 0 0 0</pose>\r\n\r\n      <inertial>\r\n        <mass>10.0</mass>\r\n        <inertia>\r\n          <ixx>0.1</ixx>\r\n          <iyy>0.1</iyy>\r\n          <izz>0.1</izz>\r\n        </inertia>\r\n      </inertial>\r\n\r\n      <collision name="collision">\r\n        <geometry>\r\n          <box>\r\n            <size>0.5 0.3 0.1</size>\r\n          </box>\r\n        </geometry>\r\n      </collision>\r\n\r\n      <visual name="visual">\r\n        <geometry>\r\n          <box>\r\n            <size>0.5 0.3 0.1</size>\r\n          </box>\r\n        </geometry>\r\n        <material>\r\n          <ambient>0 0 1 1</ambient>\r\n          <diffuse>0 0 1 1</diffuse>\r\n        </material>\r\n      </visual>\r\n    </link>\r\n\r\n    \x3c!-- Left wheel --\x3e\r\n    <link name="left_wheel">\r\n      <pose>0 0.2 0.1 -1.5707 0 0</pose>\r\n      <inertial>\r\n        <mass>1.0</mass>\r\n        <inertia>\r\n          <ixx>0.01</ixx>\r\n          <iyy>0.01</iyy>\r\n          <izz>0.01</izz>\r\n        </inertia>\r\n      </inertial>\r\n      <collision name="collision">\r\n        <geometry>\r\n          <cylinder>\r\n            <radius>0.1</radius>\r\n            <length>0.05</length>\r\n          </cylinder>\r\n        </geometry>\r\n      </collision>\r\n      <visual name="visual">\r\n        <geometry>\r\n          <cylinder>\r\n            <radius>0.1</radius>\r\n            <length>0.05</length>\r\n          </cylinder>\r\n        </geometry>\r\n        <material>\r\n          <ambient>0.2 0.2 0.2 1</ambient>\r\n          <diffuse>0.2 0.2 0.2 1</diffuse>\r\n        </material>\r\n      </visual>\r\n    </link>\r\n\r\n    \x3c!-- Right wheel --\x3e\r\n    <link name="right_wheel">\r\n      <pose>0 -0.2 0.1 -1.5707 0 0</pose>\r\n      <inertial>\r\n        <mass>1.0</mass>\r\n        <inertia>\r\n          <ixx>0.01</ixx>\r\n          <iyy>0.01</iyy>\r\n          <izz>0.01</izz>\r\n        </inertia>\r\n      </inertial>\r\n      <collision name="collision">\r\n        <geometry>\r\n          <cylinder>\r\n            <radius>0.1</radius>\r\n            <length>0.05</length>\r\n          </cylinder>\r\n        </geometry>\r\n      </collision>\r\n      <visual name="visual">\r\n        <geometry>\r\n          <cylinder>\r\n            <radius>0.1</radius>\r\n            <length>0.05</length>\r\n          </cylinder>\r\n        </geometry>\r\n        <material>\r\n          <ambient>0.2 0.2 0.2 1</ambient>\r\n          <diffuse>0.2 0.2 0.2 1</diffuse>\r\n        </material>\r\n      </visual>\r\n    </link>\r\n\r\n    \x3c!-- Joints: Connect wheels to base --\x3e\r\n    <joint name="left_wheel_joint" type="revolute">\r\n      <parent>base_link</parent>\r\n      <child>left_wheel</child>\r\n      <axis>\r\n        <xyz>0 1 0</xyz>\r\n      </axis>\r\n    </joint>\r\n\r\n    <joint name="right_wheel_joint" type="revolute">\r\n      <parent>base_link</parent>\r\n      <child>right_wheel</child>\r\n      <axis>\r\n        <xyz>0 1 0</xyz>\r\n      </axis>\r\n    </joint>\r\n\r\n    \x3c!-- Differential drive plugin for ROS 2 control --\x3e\r\n    <plugin\r\n      filename="gz-sim-diff-drive-system"\r\n      name="gz::sim::systems::DiffDrive">\r\n      <left_joint>left_wheel_joint</left_joint>\r\n      <right_joint>right_wheel_joint</right_joint>\r\n      <wheel_separation>0.4</wheel_separation>\r\n      <wheel_radius>0.1</wheel_radius>\r\n      <topic>/cmd_vel</topic>\r\n    </plugin>\r\n\r\n  </model>\r\n</sdf>\n'})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Key Concepts:"})}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Links"}),": Rigid bodies with mass, inertia, collision, and visual geometry"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Joints"}),": Connections between links (revolute = rotating, like wheels)"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Inertia"}),": Mass distribution affects how the robot moves"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Plugins"}),": Add behavior (here, differential drive controller)"]}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Spawning the robot:"})}),"\n",(0,s.jsx)(e.p,{children:"Create a world file that includes the robot:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-xml",children:'<?xml version="1.0" ?>\r\n<sdf version="1.8">\r\n  <world name="robot_world">\r\n    <physics name="1ms" type="ode">\r\n      <max_step_size>0.001</max_step_size>\r\n      <real_time_factor>1</real_time_factor>\r\n    </physics>\r\n\r\n    <light type="directional" name="sun">\r\n      <pose>0 0 10 0 0 0</pose>\r\n      <diffuse>1 1 1 1</diffuse>\r\n      <direction>-0.5 0.1 -0.9</direction>\r\n    </light>\r\n\r\n    <include>\r\n      <uri>model://ground_plane</uri>\r\n    </include>\r\n\r\n    <include>\r\n      <uri>file://diff_drive_robot.sdf</uri>\r\n      <pose>0 0 0.2 0 0 0</pose>\r\n    </include>\r\n  </world>\r\n</sdf>\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:"gz sim robot_world.sdf\n"})}),"\n",(0,s.jsx)(e.h3,{id:"controlling-the-robot-with-ros-2",children:"Controlling the Robot with ROS 2"}),"\n",(0,s.jsxs)(e.p,{children:["The differential drive plugin subscribes to ",(0,s.jsx)(e.code,{children:"/cmd_vel"})," (Twist messages). Let's control it from ROS 2."]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Test with command-line:"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:'ros2 topic pub /cmd_vel geometry_msgs/msg/Twist \\\r\n  "{linear: {x: 0.5}, angular: {z: 0.0}}"\n'})}),"\n",(0,s.jsx)(e.p,{children:"The robot should move forward!"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Control with Python:"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"import rclpy\r\nfrom rclpy.node import Node\r\nfrom geometry_msgs.msg import Twist\r\n\r\nclass GazeboRobotController(Node):\r\n    def __init__(self):\r\n        super().__init__('gazebo_robot_controller')\r\n        self.publisher = self.create_publisher(Twist, '/cmd_vel', 10)\r\n        self.timer = self.create_timer(0.1, self.move_robot)\r\n        self.get_logger().info('Gazebo Robot Controller started!')\r\n\r\n    def move_robot(self):\r\n        cmd = Twist()\r\n        cmd.linear.x = 0.5  # Move forward at 0.5 m/s\r\n        cmd.angular.z = 0.2  # Turn slightly\r\n        self.publisher.publish(cmd)\r\n\r\ndef main():\r\n    rclpy.init()\r\n    node = GazeboRobotController()\r\n    rclpy.spin(node)\r\n    node.destroy_node()\r\n    rclpy.shutdown()\r\n\r\nif __name__ == '__main__':\r\n    main()\n"})}),"\n",(0,s.jsx)(e.h3,{id:"adding-a-lidar-sensor",children:"Adding a Lidar Sensor"}),"\n",(0,s.jsx)(e.p,{children:"Let's add a lidar to the robot for obstacle detection."}),"\n",(0,s.jsxs)(e.p,{children:["Add this to the robot SDF (inside the ",(0,s.jsx)(e.code,{children:"<model>"})," tag):"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-xml",children:'\x3c!-- Lidar sensor --\x3e\r\n<link name="lidar_link">\r\n  <pose>0.2 0 0.2 0 0 0</pose>\r\n  <collision name="collision">\r\n    <geometry>\r\n      <cylinder>\r\n        <radius>0.05</radius>\r\n        <length>0.1</length>\r\n      </cylinder>\r\n    </geometry>\r\n  </collision>\r\n  <visual name="visual">\r\n    <geometry>\r\n      <cylinder>\r\n        <radius>0.05</radius>\r\n        <length>0.1</length>\r\n      </cylinder>\r\n    </geometry>\r\n  </visual>\r\n\r\n  \x3c!-- Lidar sensor definition --\x3e\r\n  <sensor name="lidar" type="gpu_lidar">\r\n    <topic>/scan</topic>\r\n    <update_rate>10</update_rate>\r\n    <lidar>\r\n      <scan>\r\n        <horizontal>\r\n          <samples>360</samples>\r\n          <resolution>1.0</resolution>\r\n          <min_angle>-3.14159</min_angle>\r\n          <max_angle>3.14159</max_angle>\r\n        </horizontal>\r\n      </scan>\r\n      <range>\r\n        <min>0.1</min>\r\n        <max>10.0</max>\r\n        <resolution>0.01</resolution>\r\n      </range>\r\n    </lidar>\r\n  </sensor>\r\n</link>\r\n\r\n\x3c!-- Joint: Attach lidar to base --\x3e\r\n<joint name="lidar_joint" type="fixed">\r\n  <parent>base_link</parent>\r\n  <child>lidar_link</child>\r\n</joint>\n'})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsxs)(e.strong,{children:["Now the robot publishes lidar data to ",(0,s.jsx)(e.code,{children:"/scan"}),"!"]})}),"\n",(0,s.jsx)(e.p,{children:"Subscribe to it from ROS 2:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:"ros2 topic echo /scan\n"})}),"\n",(0,s.jsx)(e.h2,{id:"practical-example-autonomous-navigation-in-gazebo",children:"Practical Example: Autonomous Navigation in Gazebo"}),"\n",(0,s.jsx)(e.p,{children:"Let's combine everything: a robot with lidar, obstacle avoidance, and autonomous movement."}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Scenario:"})," Robot navigates around obstacles using lidar feedback."]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Python Controller:"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"import rclpy\r\nfrom rclpy.node import Node\r\nfrom sensor_msgs.msg import LaserScan\r\nfrom geometry_msgs.msg import Twist\r\n\r\nclass AutonomousNavigator(Node):\r\n    def __init__(self):\r\n        super().__init__('autonomous_navigator')\r\n\r\n        self.scan_sub = self.create_subscription(\r\n            LaserScan, '/scan', self.scan_callback, 10\r\n        )\r\n        self.cmd_pub = self.create_publisher(Twist, '/cmd_vel', 10)\r\n\r\n        self.safe_distance = 1.0  # meters\r\n        self.get_logger().info('Autonomous Navigator started!')\r\n\r\n    def scan_callback(self, msg):\r\n        # Find closest obstacle\r\n        valid_ranges = [r for r in msg.ranges if 0.1 < r < 10.0]\r\n        if not valid_ranges:\r\n            return\r\n\r\n        min_distance = min(valid_ranges)\r\n        min_index = msg.ranges.index(min_distance)\r\n\r\n        cmd = Twist()\r\n\r\n        if min_distance < self.safe_distance:\r\n            # Obstacle ahead! Turn away\r\n            # Determine turn direction based on obstacle position\r\n            if min_index < len(msg.ranges) / 2:\r\n                # Obstacle on the left, turn right\r\n                cmd.angular.z = -0.5\r\n            else:\r\n                # Obstacle on the right, turn left\r\n                cmd.angular.z = 0.5\r\n            cmd.linear.x = 0.1  # Slow down\r\n\r\n            self.get_logger().info(\r\n                f'Avoiding obstacle at {min_distance:.2f}m (turning)'\r\n            )\r\n        else:\r\n            # Path clear, move forward\r\n            cmd.linear.x = 0.5\r\n            cmd.angular.z = 0.0\r\n            self.get_logger().info('Path clear, moving forward')\r\n\r\n        self.cmd_pub.publish(cmd)\r\n\r\ndef main():\r\n    rclpy.init()\r\n    node = AutonomousNavigator()\r\n    rclpy.spin(node)\r\n    node.destroy_node()\r\n    rclpy.shutdown()\r\n\r\nif __name__ == '__main__':\r\n    main()\n"})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Expected Behavior:"})}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsx)(e.li,{children:"Robot moves forward when path is clear"}),"\n",(0,s.jsx)(e.li,{children:"When lidar detects obstacle < 1m, robot slows and turns"}),"\n",(0,s.jsx)(e.li,{children:"Robot chooses turn direction based on obstacle position"}),"\n",(0,s.jsx)(e.li,{children:"Continues navigating autonomously"}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"visual-aids",children:"Visual Aids"}),"\n",(0,s.jsx)(e.h3,{id:"gazebo-simulation-pipeline",children:"Gazebo Simulation Pipeline"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:"Design Robot    \u2192    Create SDF Model    \u2192    Spawn in Gazebo\r\n(CAD, Sketch)        (XML description)        (Simulation)\r\n                                                    \u2193\r\nTest IRL       \u2190    Transfer Learning    \u2190    Sim with ROS 2\r\n(Real Robot)         (Sim-to-Real)            (Algorithm Dev)\n"})}),"\n",(0,s.jsx)(e.h3,{id:"sdf-model-structure",children:"SDF Model Structure"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:"<model>\r\n \u251c\u2500\u2500 <link> (base_link)\r\n \u2502    \u251c\u2500\u2500 <collision> (physics shape)\r\n \u2502    \u251c\u2500\u2500 <visual> (what you see)\r\n \u2502    \u251c\u2500\u2500 <inertial> (mass, inertia)\r\n \u2502    \u2514\u2500\u2500 <sensor> (optional)\r\n \u2502\r\n \u251c\u2500\u2500 <link> (wheel, arm, etc.)\r\n \u2502    \u2514\u2500\u2500 ...\r\n \u2502\r\n \u2514\u2500\u2500 <joint> (connects links)\r\n      \u251c\u2500\u2500 <parent> link\r\n      \u251c\u2500\u2500 <child> link\r\n      \u2514\u2500\u2500 <axis> (rotation/translation direction)\n"})}),"\n",(0,s.jsx)(e.h2,{id:"summary-and-next-steps",children:"Summary and Next Steps"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Key Takeaways:"})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Gazebo provides realistic physics and sensor simulation for robots"}),"\n",(0,s.jsx)(e.li,{children:"Robot models are defined using SDF (or URDF) XML files"}),"\n",(0,s.jsx)(e.li,{children:"Models consist of links (bodies), joints (connections), and plugins (behaviors)"}),"\n",(0,s.jsx)(e.li,{children:"Gazebo integrates seamlessly with ROS 2 via topics and services"}),"\n",(0,s.jsx)(e.li,{children:"Sensors publish data just like real hardware"}),"\n",(0,s.jsx)(e.li,{children:"Simulation enables rapid iteration and safe testing"}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"What You've Learned:"}),"\r\nYou can now create Gazebo worlds, design robot models with SDF, spawn robots in simulation, control them via ROS 2, and add sensors like lidar. You understand the relationship between physics simulation and real-world robotics."]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Up Next:"}),"\r\nIn ",(0,s.jsx)(e.a,{href:"/Physical-AI-Humanoid-Robotics/docs/chapter5_unity_simulation",children:"Chapter 5: Unity for Robotics Simulation"}),", we'll explore an alternative simulation platform. Unity offers high-quality rendering, VR/AR support, and a massive asset library\u2014ideal for human-robot interaction, synthetic data generation, and visually rich environments."]}),"\n",(0,s.jsx)(e.h2,{id:"exercises-and-challenges",children:"Exercises and Challenges"}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Exercise 1: Modify the Robot"}),"\r\nChange the differential drive robot to have:"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"4 wheels instead of 2 (add two more wheel links and joints)"}),"\n",(0,s.jsxs)(e.li,{children:["A different color (modify the ",(0,s.jsx)(e.code,{children:"<material>"})," tags)"]}),"\n",(0,s.jsxs)(e.li,{children:["A camera sensor (research ",(0,s.jsx)(e.code,{children:'<sensor type="camera">'}),")"]}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Exercise 2: Build a Custom World"}),"\r\nCreate a Gazebo world with:"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Multiple obstacles of different shapes (boxes, cylinders, spheres)"}),"\n",(0,s.jsx)(e.li,{children:"Varying terrain (add ramps, stairs, or uneven ground)"}),"\n",(0,s.jsx)(e.li,{children:"Multiple light sources"}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Exercise 3: Sensor Fusion"}),"\r\nAdd both a camera and lidar to the robot. Write a ROS 2 node that:"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["Subscribes to both ",(0,s.jsx)(e.code,{children:"/scan"})," and ",(0,s.jsx)(e.code,{children:"/camera/image"})]}),"\n",(0,s.jsx)(e.li,{children:"Logs when obstacles are detected by lidar"}),"\n",(0,s.jsx)(e.li,{children:"Saves camera images when obstacles are nearby"}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Challenge: Wall-Following Robot"}),"\r\nImplement a wall-following algorithm:"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Robot should stay 0.5m from the right wall"}),"\n",(0,s.jsx)(e.li,{children:"Use lidar data to measure distance to wall"}),"\n",(0,s.jsx)(e.li,{children:"Implement PD control for smooth following"}),"\n",(0,s.jsx)(e.li,{children:"Handle corners and gaps in walls"}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"further-reading",children:"Further Reading"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.a,{href:"https://gazebosim.org/docs",children:"Gazebo Documentation"})," - Official Gazebo tutorials and API reference"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.a,{href:"http://sdformat.org/",children:"SDF Specification"})," - Complete SDF format documentation"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.a,{href:"https://github.com/gazebosim/ros_gz",children:"ros_gz Bridge"})," - ROS 2 to Gazebo integration"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.a,{href:"https://app.gazebosim.org/fuel/models",children:"Gazebo Models Database"})," - Community-contributed robot models"]}),"\n"]}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Ready to continue?"})," Chapter 5: Unity for Robotics Simulation will be available soon!"]})]})}function h(n={}){const{wrapper:e}={...(0,l.R)(),...n.components};return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(c,{...n})}):c(n)}},8453:(n,e,r)=>{r.d(e,{R:()=>o,x:()=>t});var i=r(6540);const s={},l=i.createContext(s);function o(n){const e=i.useContext(l);return i.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function t(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(s):n.components||s:o(n.components),i.createElement(l.Provider,{value:e},n.children)}}}]);